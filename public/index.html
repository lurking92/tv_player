<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TV Subtitle（本機：情境 + 攝影機</title>
  <style>
    :root { color-scheme: dark; }
    body { background:#0f1115; color:#eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, "PingFang TC", "Microsoft JhengHei", sans-serif; margin:16px; }
    .row { display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    select, button, label { background:#1d2027; color:#eaeaea; border:none; border-radius:8px; padding:8px 12px; }
    button { cursor:pointer; }
    .screen { position:relative; width:100%; max-width:960px; aspect-ratio:16/9; border:1px solid #2a2f3a; border-radius:10px; background:#000; }
    .screen video { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; }
    .caption { position:absolute; left:0; right:0; bottom:10px; text-align:center; }
    .caption span { background:rgba(0,0,0,.55); padding:6px 10px; border-radius:6px; }
    #diag { margin-left:8px; opacity:.8; font-size:12px; }
    #meta { opacity:.8; font-size:12px; }
    
    /* 除錯面板樣式 */
    .debug-panel { 
      background:#1a1e24; 
      border:1px solid #2a2f3a; 
      border-radius:8px; 
      padding:12px; 
      margin:16px 0; 
      font-family:monospace; 
      font-size:12px; 
      max-height:200px; 
      overflow-y:auto; 
    }
    .debug-title { color:#4a9eff; font-weight:bold; margin-bottom:8px; }
    .debug-item { margin:4px 0; }
    .debug-success { color:#4ade80; }
    .debug-error { color:#ef4444; }
    .debug-warning { color:#ff8a04; }
    .debug-info { color:#8b5cf6; }
    
    /* 手動進度條樣式 */
    .progress-container { 
      margin:8px 0; 
      display:flex; 
      align-items:center; 
      gap:8px; 
    }
    .progress-bar { 
      flex:1; 
      height:6px; 
      background:#2a2f3a; 
      border-radius:3px; 
      cursor:pointer; 
      position:relative; 
    }
    .progress-filled { 
      height:100%; 
      background:#4a9eff; 
      border-radius:3px; 
      width:0%; 
      transition:width 0.1s; 
    }
    .time-display { 
      font-size:11px; 
      color:#888; 
      min-width:80px; 
    }
  </style>
</head>
<body>
  <h1>TV Subtitle（本機：情境 sceneX_DayY + 攝影機 1~5</h1>

  <div class="row">
    <label>情境：</label>
    <select id="sceneSelect"></select>

    <label>攝影機：</label>
    <select id="angleSelect">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
    </select>

    <label style="margin-left:8px;">
      <input type="checkbox" id="autoPlayToggle" checked />
      自動按順序播放
    </label>
    <label style="margin-left:8px;">
      <input type="checkbox" id="aiToggle" />
      AI分析（即時偵測）
    </label>
    <button id="testAI" style="background:#4a9eff;">測試 AI API</button>
    <span id="diag"></span>
  </div>

  <!-- 除錯面板 -->
  <div class="debug-panel">
    <div class="debug-title">API debug資訊</div>
    <div id="debugLog">等待 API 測試...</div>
  </div>

  <div class="screen">
    <div id="alertOverlay" style="position:absolute; top:10px; right:10px; padding:6px 10px; background:rgba(200,0,0,.85); color:#fff; border-radius:6px; display:none; z-index:5; font-weight:600;">警告</div>
    <canvas id="framegrab" width="0" height="0" style="display:none"></canvas>
    <video id="player" controls playsinline></video>
    <div class="caption"><span id="captionText">（敘述暫無）</span></div>
  </div>

  <!-- 手動進度條 -->
  <div class="progress-container">
    <div class="time-display" id="currentTime">0:00</div>
    <div class="progress-bar" id="progressBar">
      <div class="progress-filled" id="progressFilled"></div>
    </div>
    <div class="time-display" id="duration">0:00</div>
  </div>

  <div class="row" style="margin-top:10px;">
    <label>活動：</label>
    <select id="videoSelect" style="min-width:360px;"></select>
    <button id="btnPlay">播放</button>
    <button id="btnPause">暫停</button>
    <button id="btnPrev">上一句</button>
    <button id="btnNext">下一句</button>
    <button id="btnReset">重置</button>
    <div id="meta"></div>
  </div>

  <div>字幕清單（敘述先空白）：</div>
  <ul id="list"></ul>

<script>
  // 以相對路徑抓 manifest.json，加上 no-store 避快取。
  const MANIFEST_URL = "./manifest.json";

  const sceneSel = document.getElementById('sceneSelect');
  const angleSel = document.getElementById('angleSelect');

  const vsel   = document.getElementById('videoSelect');
  const player = document.getElementById('player');
  const caption= document.getElementById('captionText');
  const list   = document.getElementById('list');
  const meta   = document.getElementById('meta');
  const diag   = document.getElementById('diag');
  const debugLog = document.getElementById('debugLog');

  let manifest = null;
  let playlist = []; // [{title, src}]
  let intervalSec = 2.5; // 敘述先空白

  // 除錯記錄函數
  function addDebugLog(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const colors = {
      success: 'debug-success',
      error: 'debug-error', 
      warning: 'debug-warning',
      info: 'debug-info'
    };
    const className = colors[type] || 'debug-info';
    debugLog.innerHTML += `<div class="debug-item"><span class="${className}">[${timestamp}] ${message}</span></div>`;
    debugLog.scrollTop = debugLog.scrollHeight;
  }

  // 測試 API 按鈕
  document.getElementById('testAI').onclick = async () => {
    addDebugLog('開始測試 AI API 連線...', 'info');
    
    // 創建一個簡單的測試圖像
    const testCanvas = document.createElement('canvas');
    testCanvas.width = 64;
    testCanvas.height = 64;
    const ctx = testCanvas.getContext('2d');
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(0, 0, 64, 64);
    const testDataUrl = testCanvas.toDataURL('image/jpeg', 0.5);
    
    try {
      const res = await fetch('/api/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ dataUrl: testDataUrl })
      });
      
      addDebugLog(`API 回應狀態: ${res.status} ${res.statusText}`, res.ok ? 'success' : 'error');
      
      if (!res.ok) {
        const errorText = await res.text();
        addDebugLog(`錯誤內容: ${errorText}`, 'error');
        return;
      }
      
      const result = await res.json();
      addDebugLog(`API 回應成功: ${JSON.stringify(result)}`, 'success');
      addDebugLog(`原始回應內容: ${JSON.stringify(result.raw || 'N/A')}`, 'info');
      
      if (result.error) {
        addDebugLog(`API 內部錯誤: ${result.error}`, 'error');
      } else if (result.result) {
        addDebugLog(`解析結果: ${JSON.stringify(result.result)}`, 'success');
      }
      
    } catch (e) {
      addDebugLog(`網路錯誤: ${e.message}`, 'error');
    }
  };

  const autoPlayToggle = () => document.getElementById('autoPlayToggle')?.checked;

  document.getElementById('btnPlay').onclick  = () => player.play();
  document.getElementById('btnPause').onclick = () => player.pause();
  document.getElementById('btnPrev').onclick  = () => { const i = vsel.selectedIndex; if (i > 0) { vsel.selectedIndex = i - 1; loadVideoByIndex(i - 1); player.play(); } };
  document.getElementById('btnNext').onclick  = () => { const i = vsel.selectedIndex; if (i + 1 < playlist.length) { vsel.selectedIndex = i + 1; loadVideoByIndex(i + 1); player.play(); } };
  document.getElementById('btnReset').onclick = () => { player.currentTime = 0; };

  vsel.onchange = () => loadVideoByIndex(vsel.selectedIndex);
  sceneSel.onchange = buildPlaylistFromManifest;
  angleSel.onchange = buildPlaylistFromManifest;

  // 影片載入錯誤時，在 Console 與畫面顯示詳細原因
  player.addEventListener('error', () => {
    const err = player.error;
    console.error('Video element error:', err, 'src=', player.currentSrc || player.src);
    meta.textContent = `影片載入失敗：${player.currentSrc || player.src}`;
  });

  // ===== 手動進度條功能 =====
  const progressBar = document.getElementById('progressBar');
  const progressFilled = document.getElementById('progressFilled');
  const currentTimeDisplay = document.getElementById('currentTime');
  const durationDisplay = document.getElementById('duration');

  function formatTime(seconds) {
    if (isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  function updateProgress() {
    if (player.duration) {
      const progress = (player.currentTime / player.duration) * 100;
      progressFilled.style.width = progress + '%';
      currentTimeDisplay.textContent = formatTime(player.currentTime);
      durationDisplay.textContent = formatTime(player.duration);
    }
  }

  // 點擊進度條跳轉
  progressBar.addEventListener('click', (e) => {
    if (player.duration) {
      const rect = progressBar.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const progress = clickX / rect.width;
      const newTime = progress * player.duration;
      player.currentTime = newTime;
      addDebugLog(`手動跳轉至 ${formatTime(newTime)}`, 'info');
    }
  });

  // 監聽影片時間更新
  player.addEventListener('timeupdate', updateProgress);
  player.addEventListener('loadedmetadata', updateProgress);

  async function loadManifest() {
    addDebugLog('開始載入 manifest.json...', 'info');
    const res = await fetch(MANIFEST_URL, { cache: "no-store" });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status} ${res.statusText} @ ${res.url}`);
    }
    const text = await res.text();
    try {
      manifest = JSON.parse(text);
      addDebugLog('manifest.json 載入成功', 'success');
    } catch (err) {
      console.error("manifest.json 不是合法 JSON，前 500 字如下：\n", text.slice(0, 500));
      addDebugLog(`manifest.json 解析失敗: ${err.message}`, 'error');
      throw new Error("manifest.json 解析失敗（JSON 格式錯誤）");
    }
    intervalSec = manifest?.config?.defaultIntervalSec ?? 2.5;
    initSceneDropdown();
  }

  function initSceneDropdown() {
    sceneSel.innerHTML = '';
    const scenes = manifest.scenes || [];
    scenes.forEach(s => {
      const opt = document.createElement('option');
      opt.value = s.id;
      opt.textContent = s.title || s.id;
      sceneSel.appendChild(opt);
    });
    if (sceneSel.options.length > 0) {
      sceneSel.selectedIndex = 0;
      buildPlaylistFromManifest();
    }
  }

  function buildPlaylistFromManifest() {
    const sceneId = sceneSel.value;
    const angle   = String(angleSel.value);
    const scene   = (manifest.scenes || []).find(s => s.id === sceneId);
    playlist = [];
    let missing = 0;

    if (!scene) {
      vsel.innerHTML = '';
      player.removeAttribute('src');
      player.load();
      meta.textContent = '找不到情境';
      list.innerHTML = '';
      caption.textContent = '（敘述暫無）';
      if (diag) diag.textContent = '';
      return;
    }

    const suffixMap = manifest.angleSuffixMap || { "1":"_0","2":"_1","3":"_2","4":"_3","5":"_4" };

    (scene.activities || []).forEach(act => {
      // 以 base + 後綴 + ext 組 URL；若 base/ext 缺失就視為缺檔
      if (!act || !act.base || !act.ext) { missing += 1; return; }
      const suffix = suffixMap[angle] || "_0";
      const src = `${act.base}${suffix}${act.ext}`;
      playlist.push({ title: `${act.name} (camera ${angle})`, src });
    });

    // 渲染活動下拉
    vsel.innerHTML = '';
    playlist.forEach((v, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = v.title;
      vsel.appendChild(opt);
    });

    if (playlist.length) {
      vsel.value = "0";
      loadVideoByIndex(0);
      meta.textContent = `可播數量=${playlist.length}`;
      addDebugLog(`載入場景 ${sceneId}，攝影機 ${angle}，共 ${playlist.length} 個影片`, 'success');
    } else {
      player.removeAttribute('src');
      player.load();
      meta.textContent = '此情境在此攝影機角度無可播影片';
      addDebugLog(`場景 ${sceneId} 在攝影機 ${angle} 無可用影片`, 'warning');
    }

    // 診斷訊息
    if (diag) {
      const totalActs = (scene.activities || []).length;
      const ok = playlist.length;
      const miss = totalActs - ok;
      diag.textContent = `活動總數=${totalActs}，可播=${ok}，缺檔=${miss}`;
    }

    // 敘述暫空
    list.innerHTML = '';
    caption.textContent = '（敘述暫無）';
  }

  function loadVideoByIndex(i) {
    const v = playlist[i];
    if (!v) return;
    player.src = v.src;
    player.currentTime = 0;
    meta.textContent = (playlist[i] && playlist[i].title) ? playlist[i].title : '';
    caption.textContent = '（敘述暫無）';
    addDebugLog(`載入影片: ${v.title}`, 'info');
    if (autoPlayToggle && typeof autoPlayToggle === 'function' && autoPlayToggle()) {
      try { player.play(); } catch (e) {}
    }
  }

  // 影片播畢自動播下一支（尊重自動播放開關）
  // 影片播畢處理
  player.addEventListener('ended', () => {
    const i = vsel.selectedIndex;
    const next = i + 1;
    if (autoPlayToggle() && next < playlist.length && !pausedForDanger) {
      addDebugLog('影片播畢，3秒後播放下一個...', 'info');
      // 延遲3秒播放下一個，讓AI有時間完成分析
      setTimeout(() => {
        if (!pausedForDanger) { // 確認沒有因危險行為暫停
          vsel.selectedIndex = next;
          loadVideoByIndex(next);
          try { player.play(); } catch (e) { /* ignore */ }
        }
      }, 3000);
    }
  });

  (async function init() {
    try {
      await loadManifest();
    } catch (e) {
      console.error(e);
      addDebugLog(`載入失敗: ${e.message}`, 'error');
      alert(`載入 manifest.json 失敗：${e.message}\n請先執行：node build_manifest.js`);
    }
  })();

  // ===== AI 影像即時分析（OpenRouter） =====
  const aiToggle = document.getElementById('aiToggle');
  const frameCanvas = document.getElementById('framegrab');
  const alertOverlay = document.getElementById('alertOverlay');
  const frameCtx = frameCanvas.getContext ? frameCanvas.getContext('2d') : null;
  let aiTimer = null;
  let aiBusy = false;

  function startAIAnalysis() {
    if (!aiToggle || !aiToggle.checked) return;
    if (aiTimer) return;
    addDebugLog('啟動 AI 即時分析', 'info');
    aiTimer = setInterval(captureAndAnalyze, 1000);
  }

  function stopAIAnalysis() {
    if (aiTimer) { 
      clearInterval(aiTimer); 
      aiTimer = null; 
      addDebugLog('停止 AI 即時分析', 'info');
    }
  }

  async function captureAndAnalyze() {
    if (!aiToggle || !aiToggle.checked) return;
    if (aiBusy) return;
    if (!frameCtx) return;
    const vw = player.videoWidth || 0;
    const vh = player.videoHeight || 0;
    if (vw === 0 || vh === 0) return;

    // 控制尺寸避免 payload 過大
    const MAX_W = 512;
    const scale = Math.min(1, MAX_W / vw);
    frameCanvas.width = Math.round(vw * scale);
    frameCanvas.height = Math.round(vh * scale);
    frameCtx.drawImage(player, 0, 0, frameCanvas.width, frameCanvas.height);

    const dataUrl = frameCanvas.toDataURL('image/jpeg', 0.75);

    aiBusy = true;
    try {
      const res = await fetch('/api/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ dataUrl })
      });
      
      if (!res.ok) {
        const errorText = await res.text();
        if (res.status === 429){
          addDebugLog(`API 請求被拒絕，OpenRouter 端請求過多，請稍後再試`, 'warning');
          return;
        }
        else if (res.status === 430){
          addDebugLog(`今日的API請求已經達到上限，請於明日繼續使用或使用另外的 API Key`, 'warning');
          return;
        }
        addDebugLog(`AI API 錯誤 ${res.status}: ${errorText}`, 'error');
        return;
      }
      
      const out = await res.json();
      
      // 詳細記錄每次分析結果
      addDebugLog(`影像分析結果: ${JSON.stringify(out.result || out)}`, 'info');
      if (out.raw) {
        addDebugLog(`AI 原始回應: ${out.raw}`, 'info');
      }
      
      updateAIUI(out);
      
      // 只在有危險行為時記錄警告
      const result = out && (out.result || out);
      const danger = result && (result.fall || result.climbing || result.running || result.disoriented);
      const which_danger = [];
      if (result.fall) which_danger.push('跌倒');
      if (result.climbing) which_danger.push('爬高');
      if (result.running) which_danger.push('奔跑');
      if (result.disoriented) which_danger.push('迷失方向');

      if (danger) {
        addDebugLog(`警告：偵測到危險行為: ${which_danger}`, 'warning');
      }
      
    } catch (e) {
      addDebugLog(`AI 分析失敗: ${e.message}`, 'error');
    } finally {
      aiBusy = false;
    }
  }

  function updateAIUI(out) {
    try {
      const result = out && (out.result || out);
      const stats = [];
      if (result.fall === true) {
        stats.push("跌倒");
        if (!pausedForDanger) {
          player.pause();
          pausedForDanger = true;
          addDebugLog('因偵測到跌倒行為，影片已自動暫停', 'warning');
        }
      }
      if(result.climbing === true){
        stats.push("爬高");
        if (!pausedForDanger) {
          player.pause();
          pausedForDanger = true;
          addDebugLog('因偵測到爬高行為，影片已自動暫停', 'warning');
        }
      }
      if(result.running === true){
        stats.push("奔跑");
        if (!pausedForDanger) {
          player.pause();
          pausedForDanger = true;
          addDebugLog('因偵測到奔跑行為，影片已自動暫停', 'warning');
        }
      } 
      if(result.disoriented === true){
        stats.push("迷失方向");
        if (!pausedForDanger) {
          player.pause();
          pausedForDanger = true;
          addDebugLog('因偵測到迷失方向，影片已自動暫停', 'warning');
        }
      } 

      if (diag) diag.textContent = stats.join('  ');

      const danger = result && (result.fall || result.climbing || result.running || result.disoriented);
      if (danger) {
        alertOverlay.style.display = 'block';
        alertOverlay.textContent = '警告：' + stats.join('  ');
      } else {
        alertOverlay.style.display = 'none';
        alertOverlay.textContent = '';
      }
    } catch (e) {
      console.warn('updateAIUI error', e);
    }
  }

  if (aiToggle) {
    aiToggle.addEventListener('change', () => {
      if (aiToggle.checked && !player.paused) startAIAnalysis();
      else stopAIAnalysis();
    });
  }
  
  player.addEventListener('play', startAIAnalysis);
  player.addEventListener('pause', stopAIAnalysis);
  player.addEventListener('ended', stopAIAnalysis);

  // 初始化時添加歡迎訊息
  addDebugLog('TV Subtitle debug系統啟動', 'success');

</script>
</body>
</html>