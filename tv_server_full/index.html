<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TV Subtitle - 影片分析與知識圖譜</title>
  <style>
    :root { color-scheme: dark; }
    /* --- body 字體 --- */
    body {
      background:#0f1115;
      color:#eaeaea;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Arial, "PingFang TC", "Microsoft JhengHei", sans-serif;
      margin:16px;
      font-size: 13px; 
    }
    .row { display:flex; gap:10px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
    select, button, label, input[type="file"]::file-selector-button {
      background:#21252e; 
      color:#eaeaea;
      border:1px solid #333946; /* 加上邊框 */
      border-radius:8px;
      padding: 9px 14px; /* 稍微加大 padding */
      font-size: 1.3em; 
    }
    input[type="file"] { color: #ccc; background: none; border: none; padding-left: 0;}
    button { cursor:pointer; transition: background-color 0.2s; }
    button:hover:not(:disabled) { background: #333946; }
    button:disabled { cursor: not-allowed; opacity: 0.6; }

    /* --- 主要佈局--- */
    .top-panels-container {
        display: flex;
        gap: 16px; /* 面板間距 */
        align-items: flex-start; /* 頂部對齊 */
        margin-bottom: 16px;
    }
    .top-panels-container > .mode-controls {
        flex: 1;
        margin-bottom: 0;
    }
    .top-panels-container > #kbert-panel {
        flex: 1;
        margin-top: 0;
        min-height: 110px;
        box-sizing: border-box;
    }

    /* --- 主要內容區 (影片 + Log) --- */
    .main-content {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      margin-bottom: 16px;
    }
    /* --- 影片容器與控制列 --- */
    .video-container {
        flex: 3;
        max-width: 960px;
        display: flex;
        flex-direction: column;
    }
    .screen {
      position:relative;
      width: 100%;
      aspect-ratio:16/9;
      border:1px solid #2a2f3a;
      border-radius:10px;
      background:#000;
      overflow: hidden; /* 確保影片不超出邊框 */
    }
    .screen video { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; cursor: pointer; }
    .video-controls { /* 包裹進度條和按鈕 */
        display: flex;
        flex-direction: column; /* 進度條在上，按鈕在下 */
        gap: 8px; /* 進度條和按鈕間距 */
        margin-top: 8px; /* 和影片的間距 */
    }
    .progress-container {
        display:flex; align-items:center; gap:8px; width: 100%;
    }
    .progress-bar { flex:1; height:8px; background:#2a2f3a; border-radius:4px; cursor:pointer; position:relative; }
    .progress-filled { height:100%; background:#4a9eff; border-radius:4px; width:0%; transition:width 0.1s; }
    .time-display { font-size:15px; color:#aaa; min-width:45px; text-align: center; }

    .buttons-container {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
    }
    #meta { opacity:.8; font-size: 1.5em; margin-left: auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px;}
    #diag { margin-left:8px; opacity:.8; font-size: 1.5em; }

    /* --- 除錯面板 (標題置頂) --- */
    .debug-panel {
        flex: 1;
        background:#1a1e24; border:1px solid #2a2f3a; border-radius:8px; padding:12px; margin: 0;
        font-family:monospace; font-size: 18px;
        display: flex;
        flex-direction: column;
        height: 540px;
        box-sizing: border-box;
    }
    .debug-title {
        color:#4a9eff; font-weight:bold; margin-bottom:8px;
        flex-shrink: 0;
    }
    #debugLog {
        flex-grow: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column-reverse; /* Log 內容反轉 */
        border-radius: 4px;
    }
    .debug-item { margin:4px 0; word-break: break-all; }
    .debug-success { color:#4ade80; }
    .debug-error { color:#ef4444; }
    .debug-warning { color:#ff8a04; }
    .debug-info { color: 0; }

    /* --- 控制項 --- */
    .mode-controls {
      background:#1a1e24; border:1px solid #2a2f3a; border-radius:8px; padding:12px;
    }
    .mode-toggle { display:flex; gap: 15px; align-items:center; margin-bottom:12px; }
    .mode-toggle label { display: flex; align-items: center; cursor: pointer;}
    .mode-toggle input[type="radio"] { margin-right: 5px; }
    #uploadStatus { font-size: 2.0em; margin-top:8px; }

    /* --- K-BERT 面板 --- */
    #kbert-panel {
      background:#1a1e24; border:1px solid #2a2f3a; border-radius:8px; padding:12px;
      font-family:monospace; font-size: 17.5px;
    }
    .status-list { list-style-type:none; padding-left:0; margin:0; line-height:1.6; }
    #kbertResult strong { color: #4a9eff; }
    #downloadButtonsContainer { margin-top: 10px; }
    #downloadButton {
        display: inline-block;
        margin-top: 10px;
        margin-right: 8px;
        padding: 8px 12px;
        background: #28a745;
        color: #fff;
        text-decoration: none;
        border-radius: 8px;
        font-size: 18px;
        border: none;
        cursor: pointer;
    }
    #downloadButton:hover { background: #218838; }

    /* 播放/暫停 按鈕圖示 */
    .play-pause-button { min-width: 84px; }
    .play-pause-button::before { content: '▶'; margin-right: 6px; }
    .play-pause-button.playing::before { content: '❚❚'; }

    .top-panels-container {
        display: flex;
        gap: 16px;
        /* align-items: flex-start; */ /* 改為 stretch 或 baseline 試試看 */
        align-items: stretch; /* 讓左右面板等高 */
        margin-bottom: 16px;
    }

    /* 確保左面板能正確伸展 */
    .top-panels-container > .mode-controls {
        flex: 1;
        margin-bottom: 0;
        display: flex; /* << 設為 flex */
        flex-direction: column; /* 設為縱向排列 */
    }
  </style>
</head>
<body>
  <h1>TV Subtitle - 影片分析與知識圖譜</h1>

  <div class="top-panels-container">
      <div class="mode-controls">
        <div class="debug-title" style="font-size: 18px;">上傳影片進行雲端分析</div>
        <div class="row">
          <input type="file" id="videoUploader" accept="video/*" />
          <button id="uploadButton" style="background:#28a745;">上傳並分析</button>
        </div>
        <div id="uploadStatus">請選擇影片檔案...</div>
        <div id="multiUploadZone" style="border: 2px dashed #333946; border-radius: 8px; padding: 40px 20px; text-align: center; margin-top: 16px; color: #888;">
          <div style="font-size: 5.0em; margin-bottom: 10px;">⬇️</div>
          <div style="font-size: 3.0em; ">若要新增檔案，請將檔案拖放到這裡。</div>
          <div style="font-size: 2.0em; margin-top: 8px; color: #aaa;">(只支援mp4檔案)附件大小限制：500MB，附件數量限制：1</div>
      </div>
      </div>

      <div id="kbert-panel">
          <div class="debug-title">後端分析進度</div>
          <ul class="status-list">
            <li>[等待] 1. 上傳影片至 GCS...</li>
            <li>[等待] 2. 觸發雲端分析管線...</li>
            <li>[等待] 3. 執行知識圖譜分析 (可能需數分鐘)...</li>
            <li>[等待] 4. 分析完成。</li>
          </ul>
          <div id="kbertResult" style="margin-top:10px;">等待影片上傳與分析...</div><div id="KbertScores" style="margin-top:15px; padding-top:10px; border-top:1px dashed #333946; font-size:13px;">
            <div class="debug-title" style="margin-bottom:5px;">風險分數 (K-BERT Placeholder)</div>
            <div>跌倒 (Fall): <span id="scoreFall">未偵測</span></div>
            <div>爬高 (Climbing): <span id="scoreClimbing">未偵測</span></div>
            <div>奔跑 (Running): <span id="scoreRunning">未偵測</span></div>
            <div>迷失 (Disoriented): <span id="scoreDisoriented">未偵測</span></div>
          </div>

          <div id="downloadButtonsContainer"></div>
      </div>
  </div>

  <div class="mode-controls">
      <div class="mode-toggle">
        <label>
          <input type="radio" name="sceneMode" value="virtual" checked />
          內建測試虛擬影片
        </label>
        <label>
          <input type="radio" name="sceneMode" value="uploaded" />
          上傳影片 (分析/預覽模式)
        </label>
        <label style="margin-left:15px;">
          <input type="checkbox" id="aiToggle" /> AI即時分析
        </label>
        <button id="testAI" style="background:#4a9eff; margin-left: 5px;">測試 AI API</button>
        <label style="margin-left:auto;">
          <input type="checkbox" id="autoPlayToggle" checked /> 自動播放 (情境模式)
        </label>
      </div>

      <div id="virtualControls" class="row">
        <label>情境：</label>
        <select id="sceneSelect"></select>
        <label>活動：</label>
        <select id="videoSelect" style="min-width:300px;"></select>
        <label>攝影機：</label>
        <select id="angleSelect">
          <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
        </select>
      </div>
  </div>
  <div id="aiReportPanel" style="background:#1a1e24; border:1px solid #2a2f3a; border-radius:8px; padding:12px; margin-bottom:16px;">
    <div class="debug-title" style="font-size : 18px; margin-bottom:5px;">AI 風險評估</div>
    <div id="aiReportDisplay" style="font-size:18.5px; line-height:1.6;">(請啟用 AI 即時分析或等待雲端分析完成)</div>
    <button id="downloadAiReportBtn" style="margin-top:10px; background:#4a9eff;" disabled>下載AI報告</button>
  </div>
  <div class="main-content">
      <div class="video-container">
          <div class="screen">
              <div id="alertOverlay" style="position:absolute; top:10px; right:10px; padding:6px 10px; background:rgba(200,0,0,.85); color:#fff; border-radius:6px; display:none; z-index:5; font-weight:600;">警告</div>
              <canvas id="framegrab" width="0" height="0" style="display:none"></canvas>
              <video id="player" playsinline></video>
          </div>

          <div class="video-controls">
              <div class="progress-container">
                  <div class="time-display" id="currentTime">0:00</div>
                  <div class="progress-bar" id="progressBar">
                      <div class="progress-filled" id="progressFilled"></div>
                  </div>
                  <div class="time-display" id="duration">0:00</div>
              </div>
              <div class="buttons-container">
                  <button id="playPauseButton" class="play-pause-button">播放</button>
                  <button id="btnPrev" title="上一個活動 (僅情境模式)">上一個</button>
                  <button id="btnNext" title="下一個活動 (僅情境模式)">下一個</button>
                  <button id="btnReset">重置</button>
                  
                  <span id="diag"></span> <div id="meta"></div>
              </div>
          </div>
      </div>
      <div class="debug-panel">
          <div class="debug-title">API debug資訊</div>
          <div id="debugLog"><div>等待操作...</div></div>
      </div>
  </div>

  <ul id="list" style="display: none;"></ul>

<script>
const MANIFEST_URL = "./manifest.json";

// --- DOM 元素 ---
const sceneSel = document.getElementById('sceneSelect');
const angleSel = document.getElementById('angleSelect');
const vsel = document.getElementById('videoSelect');
const player = document.getElementById('player');
const list = document.getElementById('list');
const meta = document.getElementById('meta');
const diag = document.getElementById('diag');
const debugLog = document.getElementById('debugLog');
const playPauseButton = document.getElementById('playPauseButton');
const downloadButtonsContainer = document.getElementById('downloadButtonsContainer');
const multiUploadZone = document.getElementById('multiUploadZone');

const virtualControls = document.getElementById('virtualControls');
const modeRadios = document.querySelectorAll('input[name="sceneMode"]');

const videoUploader = document.getElementById('videoUploader');
const uploadButton = document.getElementById('uploadButton');
const uploadStatus = document.getElementById('uploadStatus');

const progressBar = document.getElementById('progressBar');
const progressFilled = document.getElementById('progressFilled');
const currentTimeDisplay = document.getElementById('currentTime');
const durationDisplay = document.getElementById('duration');

const aiToggle = document.getElementById('aiToggle');
const frameCanvas = document.getElementById('framegrab');
const alertOverlay = document.getElementById('alertOverlay');
const frameCtx = frameCanvas.getContext ? frameCanvas.getContext('2d', { willReadFrequently: true }) : null;

const autoPlayToggle = document.getElementById('autoPlayToggle');
const kbertPanel = document.getElementById('kbert-panel');
const kbertResultDiv = document.getElementById('kbertResult');

// 全域variables
let manifest = null;
let playlist = [];
let intervalSec = 2.5;
let currentMode = 'virtual';
let pausedForDanger = false;
let aiTimer = null;
let aiBusy = false;
let reportTimer = null; // 慢速報告的計時器
let reportBusy = false; // 慢速報告的flag
let pollingInterval = null;
let uploadedVideoInfo = null;
let currentAnalysisReport = null; // 儲存雲端分析報告
let accumulatedAiReport = ""; //用於累積 AI 報告的變數

// 除錯輸出
function addDebugLog(message, type = 'info') {
  if (!debugLog) return;
  const timestamp = new Date().toLocaleTimeString([], { hour12: false });
  const classMap = { success: 'debug-success', error: 'debug-error', warning: 'debug-warning', info: 'debug-info' };
  const className = classMap[type] || 'debug-info';
  const wrapper = document.createElement('div');
  wrapper.className = 'debug-item';
  wrapper.innerHTML = `<span class="${className}">[${timestamp}] ${message}</span>`;
  debugLog.insertBefore(wrapper, debugLog.firstChild);
  const maxLogLines = 100;
  while (debugLog.childElementCount > maxLogLines) {
    debugLog.removeChild(debugLog.lastElementChild);
  }
  const panel = debugLog;
  if (panel) panel.scrollTop = 0;
}

// --- 模式切換 ---
function toggleControlsForMode(mode) {
  const isVirtual = mode === 'virtual';
  virtualControls.style.display = isVirtual ? 'flex' : 'none';
  document.getElementById('btnPrev').disabled = !isVirtual;
  document.getElementById('btnNext').disabled = !isVirtual;
  autoPlayToggle.disabled = !isVirtual;
  if (!isVirtual) autoPlayToggle.checked = false;
}

function clearPlayerAndUI() {
  player.removeAttribute('src');
  try { player.load(); } catch (_) {}
  meta.textContent = '';
  if (diag) diag.textContent = '';
  currentTimeDisplay.textContent = '0:00';
  durationDisplay.textContent = '0:00';
  progressFilled.style.width = '0%';
  alertOverlay.style.display = 'none';
  stopAIAnalysis();
  updatePlayPauseButton();
}

function clearVirtualSceneUI() {
  playlist = [];
  vsel.innerHTML = '<option value="-1">-- 請選擇活動 --</option>';
  list.innerHTML = '';
}

function switchMode(mode) {
  const previousMode = currentMode;
  currentMode = mode;
  toggleControlsForMode(mode);

  if (previousMode !== mode) player.pause();

  if (mode === 'virtual') {
    if (manifest) {
      buildPlaylistFromManifest();
    } else {
      clearPlayerAndUI();
      meta.textContent = 'Manifest 未載入';
    }
    addDebugLog('切換至 內建測試虛擬影片 模式', 'info');
  } else {
    clearVirtualSceneUI();
    if (uploadedVideoInfo && uploadedVideoInfo.url) {
      player.src = uploadedVideoInfo.url;
      player.load();
      meta.textContent = `預覽檔案：${uploadedVideoInfo.name}`;
      addDebugLog(`切換至 上傳模式，顯示預覽：${uploadedVideoInfo.name}`, 'info');
    } else {
      clearPlayerAndUI();
      meta.textContent = '請先上傳影片';
      addDebugLog('切換至 上傳模式，等待上傳...', 'info');
    }
  }
  updateProgress();
  updatePlayPauseButton();
  resetAiReport();
}
modeRadios.forEach(radio => radio.addEventListener('change', e => switchMode(e.target.value)));

function updatePlayPauseButton() {
  const playing = !player.paused && !player.ended && player.currentTime > 0;
  playPauseButton.classList.toggle('playing', playing);
  playPauseButton.textContent = playing ? '暫停' : '播放';
}
playPauseButton.onclick = togglePlayPause;
player.addEventListener('click', togglePlayPause);
player.addEventListener('play', updatePlayPauseButton);
player.addEventListener('pause', updatePlayPauseButton);
player.addEventListener('ended', updatePlayPauseButton);

document.getElementById('btnPrev').onclick  = () => {
  if (currentMode !== 'virtual') return;
  const i = vsel.selectedIndex;
  if (i > 0) { vsel.selectedIndex = i - 1; loadVideoByIndex(i - 1); }
  else { addDebugLog('已經是第一個影片', 'warning'); }
};
document.getElementById('btnNext').onclick  = () => {
  if (currentMode !== 'virtual') return;
  const i = vsel.selectedIndex;
  if (i + 1 < playlist.length) { vsel.selectedIndex = i + 1; loadVideoByIndex(i + 1); }
  else { addDebugLog('已經是最後一個影片', 'warning'); }
};
document.getElementById('btnReset').onclick = () => { 
  player.currentTime = 0; 
  resetAiReport();
};

// --- 影片錯誤 ---
player.addEventListener('error', () => {
  const err = player.error;
  const src = player.currentSrc || player.src || '未知來源';
  const errMsg = err ? `Code ${err.code}: ${err.message}` : '未知錯誤';
  meta.textContent = `影片載入失敗: ${src}`;
  addDebugLog(`影片錯誤: ${errMsg} (來源: ${src})`, 'error');
});

// --- 進度條 ---
function formatTime(seconds) {
  if (isNaN(seconds) || seconds < 0) return '0:00';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}
function updateProgress() {
  const duration = player.duration;
  const currentTime = player.currentTime;
  if (!isNaN(duration) && duration > 0) {
    const progress = (currentTime / duration) * 100;
    progressFilled.style.width = progress + '%';
    currentTimeDisplay.textContent = formatTime(currentTime);
    durationDisplay.textContent = formatTime(duration);
  } else {
    progressFilled.style.width = '0%';
    currentTimeDisplay.textContent = '0:00';
    durationDisplay.textContent = '0:00';
  }
}
progressBar.addEventListener('click', (e) => {
  const duration = player.duration;
  if (isNaN(duration) || duration <= 0) return addDebugLog('無法跳轉，影片長度未知', 'warning');
  const rect = progressBar.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const progressBarWidth = rect.width;
  if (progressBarWidth <= 0) return;
  const newTime = (clickX / progressBarWidth) * duration;
  player.currentTime = Math.max(0, Math.min(newTime, duration));
  addDebugLog(`手動跳轉至 ${formatTime(player.currentTime)}`, 'info');
  updateProgress();
});
player.addEventListener('timeupdate', updateProgress);
player.addEventListener('loadedmetadata', updateProgress);
player.addEventListener('durationchange', updateProgress);
player.addEventListener('seeked', updateProgress);

// --- Manifest 載入與 Virtual Scene ---
async function loadManifest() {
  addDebugLog('開始載入 manifest.json...', 'info');
  try {
    const res = await fetch(MANIFEST_URL, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} @ ${res.url}`);
    const text = await res.text();
    try {
      manifest = JSON.parse(text);
      addDebugLog('manifest.json 載入成功', 'success');
    } catch (err) {
      addDebugLog(`manifest.json 解析失敗: ${err.message}`, 'error');
      throw new Error("manifest.json 解析失敗（JSON 格式錯誤）");
    }
    intervalSec = manifest?.config?.defaultIntervalSec ?? 2.5;
    initSceneDropdown();
    const initialMode = document.querySelector('input[name="sceneMode"]:checked').value;
    
    sceneSel.removeEventListener('change', buildPlaylistFromManifest);
    angleSel.removeEventListener('change', buildPlaylistFromManifest);
    vsel.removeEventListener('change', handleVideoSelectChange);

    sceneSel.addEventListener('change', buildPlaylistFromManifest);
    angleSel.addEventListener('change', buildPlaylistFromManifest);
    vsel.addEventListener('change', handleVideoSelectChange);
    switchMode(initialMode);
  } catch (e) {
    addDebugLog(`載入 manifest.json 失敗: ${e.message}`, 'error');
    meta.textContent = `載入 manifest.json 失敗: ${e.message}`;
    switchMode(document.querySelector('input[name="sceneMode"]:checked').value || 'virtual');
  }
}

function handleVideoSelectChange(e) {
  const idx = e.target.value;
  loadVideoByIndex(idx);
}

function initSceneDropdown() {
  sceneSel.innerHTML = '';
  const scenes = manifest?.virtualScenes || manifest?.scenes || [];
  if (scenes.length === 0) { addDebugLog('manifest 中找不到 virtualScenes 或 scenes', 'warning'); return; }
  scenes.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.id;
    opt.textContent = s.title || s.id;
    sceneSel.appendChild(opt);
  });
  if (sceneSel.options.length > 0) sceneSel.selectedIndex = 0;
}

// --- [輔助函式] 使用內建數據更新 K-BERT 面板 ---
function updateKbertPanelWithBuiltIn(riskData) {
    if (!riskData) {
        resetKbertPanel();
        return;
    }

    // 更新分數
    const riskMap = {
        'Fall': 'scoreFall',
        'Fall_with_climb': 'scoreClimbing',
        'Run_with_disorientation': 'scoreRunning',
        'Walk_with_memory_loss': 'scoreDisoriented'
    };

    let hasDanger = false;
    let highRiskActions = [];

    for (const [riskName, elemId] of Object.entries(riskMap)) {
        const prob = riskData[riskName];
        const el = document.getElementById(elemId);
        if (el && prob !== undefined) {
            el.textContent = prob.toFixed(3);
            if (prob > 0.5) {
                el.style.color = "#ef4444"; // 紅色
                hasDanger = true;
                highRiskActions.push(riskName);
            } else {
                el.style.color = "#eaeaea"; // 恢復原色
            }
        }
    }

    // 更新文字摘要並設定 global context
    const kbertResultDivEl = document.getElementById('kbertResult');
    if (kbertResultDivEl) {
        if (hasDanger) {
            kbertResultDivEl.innerHTML = `
                <div class="debug-title" style="border-top:1px solid #2a2f3a; padding-top:10px;">K-BERT 分析結果 (內建)</div>
                <div><strong>分析摘要:</strong> 偵測到潛在風險: ${highRiskActions.join(", ")}</div>
                <div><strong>偵測到危險:</strong> <span style="color:#ef4444; font-weight:bold;">是</span></div>
            `;
             currentAnalysisReport = { 
                 analysis: { 
                     kbert_analysis: { 
                         summary: `偵測到潛在風險: ${highRiskActions.join(", ")}`,
                         contains_danger: true 
                     } 
                 } 
             };
        } else {
            kbertResultDivEl.innerHTML = `
                <div class="debug-title" style="border-top:1px solid #2a2f3a; padding-top:10px;">K-BERT 分析結果 (內建)</div>
                <div><strong>分析摘要:</strong> 未偵測到明顯風險。</div>
                <div><strong>偵測到危險:</strong> <span style="color:#4ade80; font-weight:bold;">否</span></div>
            `;
             currentAnalysisReport = { 
                 analysis: { 
                     kbert_analysis: { 
                         summary: "未偵測到明顯風險。",
                         contains_danger: false 
                     } 
                 } 
             };
        }
    }
}

function buildPlaylistFromManifest() {
  if (currentMode !== 'virtual' || !manifest) return;
  const sceneId = sceneSel.value;
  const angle = String(angleSel.value);
  const scenes = manifest.virtualScenes || manifest.scenes || [];
  const scene = scenes.find(s => s.id === sceneId);
  playlist = [];
  
  if (!scene) {
    vsel.innerHTML = '<option value="-1">-- 請選擇活動 --</option>';
    clearPlayerAndUI();
    meta.textContent = '找不到資料';
    list.innerHTML = '';
    if (diag) diag.textContent = '';
    resetKbertPanel();
    addDebugLog(`找不到 ID 為 ${sceneId} 的情境`, 'warning');
    return;
  }

  // [關鍵] 讀取並顯示內建風險數據
  updateKbertPanelWithBuiltIn(scene.riskAnalysis);

  const suffixMap = manifest.angleSuffixMap || { "1": "_0", "2": "_1", "3": "_2", "4": "_3", "5": "_4" };
  const activities = scene.activities || [];
  activities.forEach(act => {
    if (!act || !act.base || !act.ext) return;
    const suffix = suffixMap[angle] || "_0";
    const cleanBase = act.base.endsWith('/') ? act.base.slice(0, -1) : act.base;
    const cleanSuffix = suffix.startsWith('/') ? suffix.slice(1) : suffix;
    const src = `${cleanBase}${cleanSuffix}${act.ext}`;
    playlist.push({ title: `${act.name} (相機 ${angle})`, src });
  });

  vsel.innerHTML = '';
  if (playlist.length > 0) {
    playlist.forEach((v, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = v.title;
      vsel.appendChild(opt);
    });
    vsel.value = "0";
    loadVideoByIndex(0); // [修復] 這裡呼叫了 loadVideoByIndex
    meta.textContent = `活動數量=${playlist.length}`;
    addDebugLog(`載入場景 ${sceneId}，相機 ${angle}，共 ${playlist.length} 個活動`, 'success');
  } else {
    vsel.innerHTML = '<option value="-1">-- 無可用活動 --</option>';
    clearPlayerAndUI();
    meta.textContent = '此情境在此相機角度無可用活動';
    addDebugLog(`場景 ${sceneId} 在相機 ${angle} 無可用活動`, 'warning');
  }
  const totalActs = activities.length;
  if (diag) diag.textContent = `總活動=${totalActs}，可播=${playlist.length}`;
  list.innerHTML = '';
}

// loadVideoByIndex 函式
function loadVideoByIndex(i) {
  if (currentMode !== 'virtual') return;
  const index = parseInt(i, 10);
  if (isNaN(index) || index < 0 || index >= playlist.length) {
    addDebugLog(`無效的影片索引: ${i}`, 'error');
    clearPlayerAndUI();
    meta.textContent = '無效的影片選擇';
    return;
  }
  const v = playlist[index];
  if (!v || !v.src) {
    addDebugLog(`索引 ${index} 缺少影片來源`, 'error');
    meta.textContent = '影片來源錯誤';
    return;
  }
  addDebugLog(`準備載入影片索引 ${index}: ${v.title}`, 'info');
  player.src = v.src;   
  player.load();        
  player.currentTime = 0;
  meta.textContent = v.title || `影片 ${index + 1}`;
  progressFilled.style.width = '0%';
  currentTimeDisplay.textContent = '0:00';
  durationDisplay.textContent = '0:00';
  alertOverlay.style.display = 'none';
  pausedForDanger = false;
  player.pause();       
  updatePlayPauseButton();
  resetAiReport();
}


player.addEventListener('ended', async () => {
  if (aiTimer) {
    clearInterval(aiTimer);
    aiTimer = null;
    addDebugLog('Video ended. Stopped interval timer.', 'info');
  }

  if (currentMode === 'virtual' && autoPlayToggle.checked && !pausedForDanger) {
    addDebugLog('影片播畢，準備執行最後一幀 AI 分析...', 'info');
    if (aiToggle.checked) {
      try {
        while (aiBusy) {
          addDebugLog('... 等待目前 AI 分析任務完成 ...', 'info');
          await new Promise(r => setTimeout(r, 100));
        }
        addDebugLog('... 執行最後一幀分析 ...', 'success');
        await captureAndAnalyze_FastCheck(true);
        addDebugLog('... 最後一幀分析完成 ...', 'success');
      } catch (e) {
        addDebugLog(`最後一幀分析失敗: ${e.message}`, 'error');
      }
    }

    const DELAY_MS = 5000; 
    addDebugLog(`等待 ${DELAY_MS / 1000} 秒後切換下個影片...`, 'info');
    await new Promise(r => setTimeout(r, DELAY_MS));

    if (currentMode !== 'virtual' || !autoPlayToggle.checked || pausedForDanger) {
      addDebugLog('延遲切換已取消 (狀態變更)', 'info');
      return; 
    }
    if (player.currentTime < player.duration) {
       addDebugLog('延遲切換已取消 (影片已非結束狀態)', 'info');
       return;
    }

    const i = vsel.selectedIndex;
    const next = i + 1;
    if (next < playlist.length) {
      addDebugLog(`... ${DELAY_MS / 1000} 秒結束，自動播放下一個...`, 'info');
      vsel.selectedIndex = next;
      loadVideoByIndex(next); 
      
      setTimeout(() => {
        if (currentMode === 'virtual' && autoPlayToggle.checked && !pausedForDanger) {
          player.play().catch(e => addDebugLog(`自動播放下一個失敗: ${e.message}`, 'warning'));
        }
      }, 150); 
    
    } else {
      addDebugLog('已播完播放列表中的所有影片', 'info');
    }

  } else if (currentMode === 'uploaded') {
    addDebugLog('上傳的影片播畢', 'info');
    if (aiToggle.checked) {
       addDebugLog('... 上傳影片播畢，執行最後一幀分析 ...', 'info');
       while (aiBusy) {
          addDebugLog('... 等待目前 AI 分析任務完成 ...', 'info');
          await new Promise(r => setTimeout(r, 100));
        }
       await captureAndAnalyze_FastCheck(true); 
       addDebugLog('... 最後一幀分析完成 ...', 'success');
    }
  }
  updatePlayPauseButton();
});

// AI 即時分析 
function startAIAnalysis() {
  if (!aiToggle || !aiToggle.checked) return;
  if (!frameCtx) { addDebugLog('Canvas context 無法初始化', 'error'); return; }

  if (!aiTimer) {
    const analysisInterval = 1000; 
    addDebugLog(`啟動 AI 快速偵測 (每 ${analysisInterval} 毫秒)`, 'info');
    aiTimer = setInterval(() => captureAndAnalyze_FastCheck(false), analysisInterval);
  }

  if (!reportTimer) {
    const reportInterval = 3000; 
    addDebugLog(`啟動 AI 慢速報告 (每 ${reportInterval / 1000} 秒)`, 'info');
    triggerSlowReport(); 
    reportTimer = setInterval(() => triggerSlowReport(), reportInterval); 
  }
}

function resetAiReport() {
    accumulatedAiReport = ""; // 清空記憶體中的報告
    const reportDisplay = document.getElementById('aiReportDisplay');
    const downloadBtn = document.getElementById('downloadAiReportBtn');
    
    if (reportDisplay) {
        reportDisplay.innerHTML = '(請啟用 AI 即時分析或等待雲端分析完成)';
        // 恢復原本的樣式 (避免文字太長時的滾動條殘留)
        reportDisplay.scrollTop = 0;
    }
    if (downloadBtn) { 
        downloadBtn.disabled = true; 
        downloadBtn.dataset.reportContent = ''; 
    }
    addDebugLog("已重置 AI 分析報告", "info");
}

function togglePlayPause() {
  if (!player.src) return;
  
  if (player.paused || player.ended) {
    // [新增] 重播偵測：如果影片是從頭開始 (且不是因為 AI 危險暫停而恢復)，則清空報告
    if (player.currentTime < 0.5 && !pausedForDanger) {
        addDebugLog("偵測到重新播放，已重置 AI 報告。", "info");
        resetAiReport();
    }

    pausedForDanger = false;
    alertOverlay.style.display = 'none';
    player.play().catch(e => addDebugLog(`播放失敗: ${e.message}`, 'error'));
  } else {
    player.pause();
  }
}
playPauseButton.onclick = togglePlayPause;
player.removeEventListener('click', togglePlayPause); 
player.addEventListener('click', togglePlayPause);

function stopAIAnalysis() {
  if (aiTimer) {
    clearInterval(aiTimer);
    aiTimer = null;
    aiBusy  = false;
    addDebugLog('停止 AI 快速偵測', 'info');
  }

  if (reportTimer) {
    clearInterval(reportTimer);
    reportTimer = null;
    reportBusy = false; 
    addDebugLog('停止 AI 慢速報告', 'info');
  }

  if (!aiToggle || !aiToggle.checked) {
    const reportDisplay = document.getElementById('aiReportDisplay');
    const downloadBtn   = document.getElementById('downloadAiReportBtn');

    const cloudReport = currentAnalysisReport?.analysis?.overall_risk_report;
    if (cloudReport) {
      if (reportDisplay) reportDisplay.innerHTML = cloudReport.replace(/\n/g, '<br>');
      if (downloadBtn)   { downloadBtn.disabled = false; downloadBtn.dataset.reportContent = cloudReport; }
    } else {
      if (reportDisplay) reportDisplay.innerHTML = '(AI 即時分析已停用)';
      if (downloadBtn)   downloadBtn.disabled = true;
    }
  }
}

async function captureAndAnalyze_FastCheck(force = false) {
  if (aiBusy || !frameCtx || !aiToggle.checked) {
    if (force && !aiBusy) addDebugLog('Final analysis skipped (toggle off)', 'warning');
    return;
  }
  if (!force && (player.paused || player.ended)) {
    return;
  }
  const vw = player.videoWidth || 0;
  const vh = player.videoHeight || 0;
  if (vw === 0 || vh === 0) {
    if (force) addDebugLog('Final analysis skipped (no video frame data)', 'warning');
    return;
  }

  aiBusy = true;
  let dataUrl = null; 
  try {
    const MAX_W = 256;
    const scale = Math.min(1, MAX_W / vw);
    frameCanvas.width = Math.round(vw * scale);
    frameCanvas.height = Math.round(vh * scale);
    frameCtx.drawImage(player, 0, 0, frameCanvas.width, frameCanvas.height);
    dataUrl = frameCanvas.toDataURL('image/jpeg', 0.4); 

    const res = await fetch('/api/check-risk', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ dataUrl })
    });

    if (!res.ok) { const errorText = await res.text(); throw new Error(`API-Fast Error ${res.status}: ${errorText}`); }
    const out = await res.json();
    if (out.error) throw new Error(`API-Fast returned error: ${out.error}`);

    updateAIUI_Fast(out.result, dataUrl); 

  } catch (e) {
    addDebugLog(`AI 快速偵測失敗: ${e.message}`, 'error');
    if (aiTimer) { clearInterval(aiTimer); aiTimer = null; }
    aiBusy = false;
  } finally {
    aiBusy = false;
  }
}

function updateAIUI_Fast(result, dataUrl) {
  try {
    if (!result) {
      if (diag) diag.textContent = '[AI分析錯誤]';
      return;
    }

    const stats = [];
    if (result.fall)        stats.push("跌倒");
    if (result.climbing)    stats.push("爬高");
    if (result.running)     stats.push("奔跑");
    if (result.disoriented) stats.push("迷失方向");

    const danger = stats.length > 0;
    const statusText = danger
      ? `<span style="color:#ef4444;">${stats.join(' / ')}</span>`
      : '<span style="color:#4ade80;">正常</span>';

    if (diag) diag.innerHTML = `[狀態: ${statusText}]`;

    if (danger) {
      alertOverlay.style.display = 'block';
      alertOverlay.textContent   = '警告：偵測到 ' + stats.join(' / ');

      if (!pausedForDanger && !player.paused) {
        player.pause();
        pausedForDanger = true;
        addDebugLog(`警告：偵測到危險行為 [${stats.join(', ')}]，影片已自動暫停`, 'warning');
        triggerSlowReport(dataUrl); 
      }
    } else {
      alertOverlay.style.display = 'none';
      alertOverlay.textContent   = '';
    }
  } catch (e) {
    addDebugLog(`更新 AI 快速狀態 UI 時出錯: ${e.message}`, 'error');
    if (diag) diag.textContent = '[UI 更新錯誤]';
  }
}

async function triggerSlowReport(dataUrl = null) {
  if (reportBusy) {
    addDebugLog('慢速報告：忙碌中，跳過此次觸發', 'info');
    return;
  }
  reportBusy = true;

  const reportDisplay = document.getElementById('aiReportDisplay');
  const downloadBtn   = document.getElementById('downloadAiReportBtn');

  // 讓舊的報告保留在畫面上，直到新的出來為止

  let finalDataUrl = dataUrl;
  try {
    if (!finalDataUrl) {
      if ((player.paused && !pausedForDanger) || player.ended) {
        throw new Error("跳過：非活動狀態");
      }
      const vw = player.videoWidth || 0;
      const vh = player.videoHeight || 0;
      if (vw === 0 || vh === 0) {
        throw new Error("跳過：無影像畫面");
      }
      const MAX_W = 256; 
      const scale = Math.min(1, MAX_W / vw);
      frameCanvas.width = Math.round(vw * scale);
      frameCanvas.height = Math.round(vh * scale);
      frameCtx.drawImage(player, 0, 0, frameCanvas.width, frameCanvas.height);
      finalDataUrl = frameCanvas.toDataURL('image/jpeg', 0.4);
    }

    if (!finalDataUrl) throw new Error("無可分析的影像資料");

    let analysisContext = null;
    if (currentAnalysisReport) {
      analysisContext = {
        visual_triples: currentAnalysisReport?.analysis?.visual_analysis?.visual_triples || [],
        kbert_summary: currentAnalysisReport?.analysis?.kbert_analysis?.summary || ""
      };
    }

    // 呼叫 API
    const res = await fetch('/api/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        dataUrl: finalDataUrl, 
        context: analysisContext
      })
    });

    if (!res.ok) { const errorText = await res.text(); throw new Error(`API-Slow Error ${res.status}: ${errorText}`); }
    const out = await res.json();
    if (out.error) throw new Error(`API-Slow returned error: ${out.error}`);

    const reportText = out?.report || "(AI 無法生成報告)";
    
    // ---累積報告邏輯 ---
    const timeStr = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
    const newEntry = `\n\n【${timeStr} 分析報告】\n${reportText}`;
    
    // 如果是第一筆，直接覆蓋預設文字；否則追加
    if (accumulatedAiReport === "") {
        accumulatedAiReport = `【${timeStr} 分析報告】\n${reportText}`;
    } else {
        accumulatedAiReport += newEntry;
    }

    // 更新 UI
    if (reportDisplay) {
        // 將換行符號轉為 <br> 以正確顯示
        reportDisplay.innerHTML = accumulatedAiReport.replace(/\n/g, '<br>');
        // 自動捲動到底部，讓使用者看到最新內容
        reportDisplay.scrollTop = reportDisplay.scrollHeight;
    }

    if (downloadBtn) {
      downloadBtn.disabled = false;
      downloadBtn.dataset.reportContent = accumulatedAiReport; // 下載包含所有歷史的報告
      downloadBtn.onclick = downloadCurrentAIReport;
    }
    addDebugLog('AI 慢速報告已更新 ', 'success');

  } catch (e) {
    if (!e.message.startsWith("跳過")) {
       addDebugLog(`AI 慢速報告失敗: ${e.message}`, 'error');
       // 失敗時不動作，保留舊文字
    } else {
       addDebugLog(`AI 慢速報告: ${e.message}`, 'info');
    }
  } finally {
    reportBusy = false; 
  }
}

async function downloadCurrentAIReport() {
  const btn = document.getElementById('downloadAiReportBtn');
  const reportText = btn ? btn.dataset.reportContent : null;

  if (!reportText || reportText === "(無分析報告)") {
    addDebugLog('沒有可下載的 AI 報告內容', 'warning');
    alert('沒有可下載的 AI 報告內容');
    return;
  }

  addDebugLog('準備下載目前的 AI 分析報告...', 'info');
  if (btn) btn.disabled = true;

  try {
    const res = await fetch('/api/download/ai_report', {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain' },
      body: reportText
    });

    if (!res.ok) {
      const errorText = await res.text();
      throw new Error(`下載失敗: ${res.status} ${errorText}`);
    }

    const blob = await res.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;

    const disposition = res.headers.get('Content-Disposition');
    let filename = 'ai_risk_report.txt';
    if (disposition && disposition.indexOf('attachment') !== -1) {
      const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
      const matches = filenameRegex.exec(disposition);
      if (matches != null && matches[1]) filename = matches[1].replace(/['"]/g, '');
    }
    a.download = filename;

    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    a.remove();
    addDebugLog('AI 報告下載成功', 'success');
  } catch (error) {
    addDebugLog(`下載 AI 報告時出錯: ${error.message}`, 'error');
    alert(`下載 AI 報告失敗: ${error.message}`);
  } finally {
    if (btn) btn.disabled = false;
  }
}

aiToggle.addEventListener('change', () => {
  if (aiToggle.checked) {
    if (!player.paused) startAIAnalysis();
    addDebugLog('AI 即時分析已啟用', 'info');
  } else {
    stopAIAnalysis();
    if (diag) diag.textContent = '';
    alertOverlay.style.display = 'none';
    addDebugLog('AI 即時分析已停用', 'info');
  }
});
player.addEventListener('play', () => { if (aiToggle.checked) startAIAnalysis(); });
player.addEventListener('emptied', stopAIAnalysis);
player.addEventListener('error', stopAIAnalysis);

document.getElementById('testAI').onclick = async () => {
  addDebugLog('開始測試 AI API 連線...', 'info');
  const btn = document.getElementById('testAI');
  btn.disabled = true;
  btn.textContent = '測試中...';
  const c = document.createElement('canvas'); c.width = 64; c.height = 64;
  const ctx = c.getContext('2d'); ctx.fillStyle = '#ff0000'; ctx.fillRect(0,0,64,64);
  const testDataUrl = c.toDataURL('image/jpeg', 0.5);
  try {
    const res = await fetch('/api/analyze', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dataUrl: testDataUrl }) });
    addDebugLog(`API 回應狀態: ${res.status} ${res.statusText}`, res.ok ? 'success' : 'error');
    if (!res.ok) { const t = await res.text(); addDebugLog(`錯誤內容: ${t}`, 'error'); throw new Error(t); }
    const result = await res.json();
    addDebugLog(`API 回應成功: ${JSON.stringify(result)}`, 'success');
    if (result.error) addDebugLog(`API 內部錯誤: ${result.error}`, 'error');
    else if (result.result) addDebugLog(`解析結果: ${JSON.stringify(result.result)}`, 'success');
  } catch (e) {
    addDebugLog(`網路或 API 錯誤: ${e.message}`, 'error');
  } finally {
    btn.disabled = false;
    btn.textContent = '測試 AI API';
  }
};

function resetKbertPanel() {
  kbertResultDiv.innerHTML = '等待影片上傳與分析...';
  downloadButtonsContainer.innerHTML = '';

  (document.getElementById('scoreFall') || {}).textContent = "未偵測";
  (document.getElementById('scoreClimbing') || {}).textContent = "未偵測";
  (document.getElementById('scoreRunning') || {}).textContent = "未偵測";
  (document.getElementById('scoreDisoriented') || {}).textContent = "未偵測";
  
  const scoreElements = ['scoreFall', 'scoreClimbing', 'scoreRunning', 'scoreDisoriented'];
  scoreElements.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.color = "#eaeaea";
  });

  const reportDisplay = document.getElementById('aiReportDisplay');
  const downloadBtn   = document.getElementById('downloadAiReportBtn');
  if (reportDisplay) reportDisplay.innerHTML = '(請啟用 AI 即時分析或等待雲端分析完成)';
  if (downloadBtn)   { downloadBtn.disabled = true; downloadBtn.dataset.reportContent = ''; }

  currentAnalysisReport = null;
}

function updateAnalysisStatusUI(stage, message = '') {
  if (!kbertPanel) return;

  let uploading = '<li>[等待] 1. 上傳影片至 GCS...</li>';
  let pending   = '<li>[等待] 2. 觸發雲端分析管線...</li>';
  let processing= '<li>[等待] 3. 執行知識圖譜分析 (可能需數分鐘)...</li>';
  let complete  = '<li>[等待] 4. 分析完成。</li>';

  if (stage === 'uploading') {
    uploading = '<li><span class="debug-info">[執行中] 1. 上傳影片至 GCS...</span></li>';
  } else if (stage === 'pending') {
    uploading = '<li><span class="debug-success">[完成] 1. 上傳影片至 GCS。</span></li>';
    pending   = '<li><span class="debug-info">[執行中] 2. 觸發雲端分析管線...</span></li>';
  } else if (stage === 'processing') {
    uploading  = '<li><span class="debug-success">[完成] 1. 上傳影片至 GCS。</span></li>';
    pending    = '<li><span class="debug-success">[完成] 2. 雲端分析已觸發。</span></li>';
    processing = '<li><span class="debug-info">[執行中] 3. 執行知識圖譜分析 (可能需數分鐘)...</span></li>';
  } else if (stage === 'complete') {
    uploading  = '<li><span class="debug-success">[完成] 1. 上傳影片至 GCS。</span></li>';
    pending    = '<li><span class="debug-success">[完成] 2. 雲端分析已觸發。</span></li>';
    processing = '<li><span class="debug-success">[完成] 3. 知識圖譜分析完畢。</span></li>';
    complete   = '<li><span class="debug-success">[完成] 4. 分析報告已載入！</span></li>';
  } else if (stage === 'error') {
    
    if (kbertPanel.innerHTML.includes('[執行中] 1.')) {
      uploading = `<li><span class="debug-error">[錯誤] 1. 上傳失敗: ${message}</span></li>`;
    } else if (kbertPanel.innerHTML.includes('[執行中] 2.')) {
      uploading = '<li><span class="debug-success">[完成] 1. 上傳影片至 GCS。</span></li>';
      pending = `<li><span class="debug-error">[錯誤] 2. 觸發失敗: ${message}</span></li>`;
    } else {
      uploading  = '<li><span class="debug-success">[完成] 1. 上傳影片至 GCS。</span></li>';
      pending    = '<li><span class="debug-success">[完成] 2. 雲端分析已觸發。</span></li>';
      processing = `<li><span class="debug-error">[錯誤] 3. 分析失敗: ${message}</span></li>`;
    }
  }

  const prevResultEl = document.getElementById('kbertResult');
  const prevButtonsEl = document.getElementById('downloadButtonsContainer');
  const currentResultHTML =
    (stage !== 'complete' && stage !== 'error' && prevResultEl)
      ? prevResultEl.innerHTML
      : '等待分析結果...';
  const currentButtonsHTML =
    (stage === 'complete' && prevButtonsEl)
      ? prevButtonsEl.innerHTML
      : '';
  
  const kbertScoresEl = document.getElementById('KbertScores');
  const currentScoresHTML = kbertScoresEl ? kbertScoresEl.innerHTML : `
      <div class="debug-title" style="margin-bottom:5px;">風險分數 (K-BERT Placeholder)</div>
      <div>跌倒 (Fall): <span id="scoreFall">未偵測</span></div>
      <div>爬高 (Climbing): <span id="scoreClimbing">未偵測</span></div>
      <div>奔跑 (Running): <span id="scoreRunning">未偵測</span></div>
      <div>迷失 (Disoriented): <span id="scoreDisoriented">未偵測</span></div>
  `;

  kbertPanel.innerHTML = `
    <div class="debug-title">後端分析進度</div>
    <ul class="status-list">${uploading}${pending}${processing}${complete}</ul>

    <div id="kbertResult" style="margin-top:10px;">${currentResultHTML}</div>

    <div id="KbertScores" style="margin-top:15px; padding-top:10px; border-top:1px dashed #333946; font-size:18px;">
      ${currentScoresHTML}
    </div>

    <div id="downloadButtonsContainer" style="margin-top:10px;">${currentButtonsHTML}</div>
  `;
}

function stopPolling() {
  if (pollingInterval) {
    clearInterval(pollingInterval);
    pollingInterval = null;
    addDebugLog('停止等待分析結果', 'info');
  }
}

function startPollingForResult(fileName) {
  stopPolling();
  addDebugLog(`等待分析檔案 ${fileName} 的分析結果 (每 1 分鐘)...`, 'info');
  updateAnalysisStatusUI('processing');
  uploadStatus.textContent = `[3/4] 後端正在分析中 (${fileName})...`;
  uploadStatus.style.color = '#4a9eff';
  let pollCount = 0;
  const maxPolls = 60; 

  pollingInterval = setInterval(async () => {
    pollCount++;
    if (pollCount > maxPolls) {
      stopPolling();
      const timeoutMsg = '等待超時 (3小時)，後端可能仍在處理或已失敗。';
      updateAnalysisStatusUI('error', timeoutMsg);
      uploadStatus.textContent = `錯誤：${timeoutMsg}`;
      uploadStatus.style.color = '#ef4444';
      addDebugLog(timeoutMsg, 'error');
      return;
    }

    try {
      addDebugLog(`[輪詢 #${pollCount}] 檢查 /api/result/${fileName}`, 'info');
      const res = await fetch(`/api/result/${fileName}`);

      if (res.status === 202) {
        addDebugLog(`... 狀態仍為 'processing' (HTTP 202)，繼續輪詢...`, 'info');
        return; 
      }

      if (res.status === 500) {
        const errorText = await res.text();
        throw new Error(`伺服器 API 錯誤: HTTP 500 ${errorText}`);
      }
      
      if (!res.ok) {
         throw new Error(`查詢失敗: HTTP ${res.status} ${res.statusText}`);
      }

      const result = await res.json(); 
      const reportStatus = result?.data?.status; 

      if (reportStatus === 'completed' || reportStatus === 'completed_with_risk') {
        stopPolling();
        uploadStatus.textContent = `[4/4] 分析完成！ (${fileName})`;
        uploadStatus.style.color = '#4ade80';
        addDebugLog(`分析完成，取得報告: ${JSON.stringify(result.data).substring(0, 100)}...`, 'success');
        displayResults(fileName, result.data); 
        
      } else if (reportStatus === 'processing') {
        addDebugLog(`... 狀態為 'processing' (Job 1 完成，Job 2 執行中)，繼續輪詢...`, 'info');
        return; 
      
      } else {
         stopPolling();
         const errorMsg = result.message || JSON.stringify(result.data?.errors || '後端作業失敗');
         updateAnalysisStatusUI('error', `後端分析失敗: ${errorMsg}`);
         addDebugLog(`後端在 JSON 中回報錯誤: ${errorMsg}`, 'error');
      }

    } catch (error) {
      stopPolling();
      const errorMsg = error.message || '輪詢時發生未知錯誤';
      updateAnalysisStatusUI('error', `輪詢錯誤: ${errorMsg}`);
      addDebugLog(`輪詢 fetch 或 JSON 解析錯誤: ${errorMsg}`, 'error');
    }
  }, 180000); 
}

function displayResults(fileName, data) {
  currentAnalysisReport = data;        
  updateAnalysisStatusUI('complete');   

  const kbert_analysis = data?.analysis?.kbert_analysis; 
  const kbertResultDivEl = document.getElementById('kbertResult');
  
  let kbertSummaryHtml = `
    <div class="debug-title" style="border-top:1px solid #2a2f3a; padding-top:10px;">K-BERT 分析結果</div>
  `;

  if (kbert_analysis && kbert_analysis.status === 'completed') {
    const summary = kbert_analysis.summary || "(無摘要)";
    const contains_danger = kbert_analysis.contains_danger || false;
    
    kbertSummaryHtml += `
      <div><strong>分析摘要:</strong> ${summary}</div>
      <div><strong>偵測到危險:</strong> <span style="color:${contains_danger ? '#ef4444' : '#4ade80'}; font-weight:bold;">${contains_danger ? '是' : '否'}</span></div>
    `;
    
    if (contains_danger) {
        alertOverlay.style.display = 'block';
        alertOverlay.textContent   = `警告：K-BERT 偵測到 ${summary}`;
    } else {
        if (!pausedForDanger) {
           alertOverlay.style.display = 'none';
        }
    }

  } else if (kbert_analysis && kbert_analysis.status === 'error') {
     kbertSummaryHtml += `
      <div><strong>K-BERT 狀態:</strong> <span class="debug-error">分析失敗</span></div>
      <div><strong>錯誤:</strong> ${kbert_analysis.summary || "未知 K-BERT 錯誤"}</div>
    `;
  } else {
    kbertSummaryHtml += `<div>(K-BERT 分析處理中或未包含)</div>`;
  }

  if (kbertResultDivEl) {
    kbertResultDivEl.innerHTML = kbertSummaryHtml;
  }
  
  const risk_details = kbert_analysis?.risk_details; 
  if (risk_details) {
    const fallProb = risk_details.Fall?.probability.toFixed(3) || "N/A";
    const climbProb = risk_details.Fall_with_climb?.probability.toFixed(3) || "N/A";
    const runProb = risk_details.Run_with_disorientation?.probability.toFixed(3) || "N/A";
    const disorientedProb = risk_details.Walk_with_memory_loss?.probability.toFixed(3) || "N/A";

    (document.getElementById('scoreFall') || {}).textContent = fallProb;
    (document.getElementById('scoreClimbing') || {}).textContent = climbProb;
    (document.getElementById('scoreRunning') || {}).textContent = runProb;
    (document.getElementById('scoreDisoriented') || {}).textContent = disorientedProb;
    
    if(risk_details.Fall?.detected) document.getElementById('scoreFall').style.color = "#ef4444";
    if(risk_details.Fall_with_climb?.detected) document.getElementById('scoreClimbing').style.color = "#ef4444";
    if(risk_details.Run_with_disorientation?.detected) document.getElementById('scoreRunning').style.color = "#ef4444";
    if(risk_details.Walk_with_memory_loss?.detected) document.getElementById('scoreDisoriented').style.color = "#ef4444";
    
    addDebugLog("已使用 K-BERT 真實機率更新分數面板", "success");
  } else {
    addDebugLog("K-BERT 報告中未找到 risk_details，分數面板維持預設", "warning");
    (document.getElementById('scoreFall') || {}).textContent = "N/A";
    (document.getElementById('scoreClimbing') || {}).textContent = "N/A";
    (document.getElementById('scoreRunning') || {}).textContent = "N/A";
    (document.getElementById('scoreDisoriented') || {}).textContent = "N/A";
  }

  const reportDisplay = document.getElementById('aiReportDisplay');
  const downloadBtn   = document.getElementById('downloadAiReportBtn');
  const overallReportText = data?.analysis?.overall_risk_report || "(雲端分析未包含 AI 評估報告)";
  if (reportDisplay && downloadBtn) {
    reportDisplay.innerHTML = overallReportText.replace(/\n/g, '<br>');
    downloadBtn.disabled    = !data?.analysis?.overall_risk_report;
    downloadBtn.dataset.reportContent = overallReportText;
    downloadBtn.onclick     = downloadCurrentAIReport;
  }

  const container = document.getElementById('downloadButtonsContainer');
  container.innerHTML = '';
  const baseName = fileName.split('.')[0];

  const reportBtn = document.createElement('button');
  reportBtn.id = 'downloadReportButton';
  reportBtn.textContent = `下載分析報告 (${baseName}_report.json)`;
  reportBtn.onclick = () => { window.location.href = `/api/download/${fileName}`; addDebugLog(`觸發下載報告 JSON: ${fileName}`, 'info'); };
  container.appendChild(reportBtn);

  const ttlBtn = document.createElement('button');
  ttlBtn.id = 'downloadTtlButton';
  ttlBtn.textContent = `下載知識圖譜 (${baseName}.ttl)`;
  ttlBtn.style.marginLeft = '10px';
  ttlBtn.onclick = () => { window.location.href = `/api/download/ttl/${fileName}`; addDebugLog(`觸發下載 TTL: ${fileName}`, 'info'); };
  container.appendChild(ttlBtn);

  const dinoTxtBtn = document.createElement('button');
  dinoTxtBtn.id = 'downloadDinoTxtButton';
  dinoTxtBtn.textContent = `下載偵測摘要 (${baseName}_dino.txt)`;
  dinoTxtBtn.style.marginLeft = '10px';
  dinoTxtBtn.onclick = () => { window.location.href = `/api/download/dino_txt/${fileName}`; addDebugLog(`觸發下載 DINO TXT: ${fileName}`, 'info'); };
  container.appendChild(dinoTxtBtn);

  const dinoZipBtn = document.createElement('button');
  dinoZipBtn.id = 'downloadDinoZipButton';
  dinoZipBtn.textContent = `下載偵測圖片 (${baseName}_dino_images.zip)`;
  dinoZipBtn.style.marginLeft = '10px';
  dinoZipBtn.onclick = () => { window.location.href = `/api/download/dino_zip/${fileName}`; addDebugLog(`觸發下載 DINO ZIP: ${fileName}`, 'info'); };
  container.appendChild(dinoZipBtn);

  meta.textContent = `分析完成：${fileName}`;
  addDebugLog(`分析完成，已顯示結果。影片 ${fileName} 為本地預覽。`, 'success');
}

function handleFileSelect(file) {
  if (!file) {
    if (uploadedVideoInfo && uploadedVideoInfo.url && uploadedVideoInfo.url.startsWith('blob:')) {
      URL.revokeObjectURL(uploadedVideoInfo.url);
    }
    uploadedVideoInfo = null;
    if (currentMode === 'uploaded') {
      clearPlayerAndUI();
      meta.textContent = '請選擇影片檔案';
    }
    uploadStatus.textContent = '請選擇影片檔案...';
    return;
  }

  const MAX_SIZE = 500 * 1024 * 1024; 
  if (file.type !== 'video/mp4') {
     addDebugLog(`檔案格式不符: ${file.name} (${file.type})`, 'warning');
     uploadStatus.textContent = `錯誤：只支援 mp4 檔案。`;
     uploadStatus.style.color = '#ef4444';
     return;
  }
  if (file.size > MAX_SIZE) {
     addDebugLog(`檔案過大: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`, 'warning');
     uploadStatus.textContent = `錯誤：檔案大小超過 500MB 限制。`;
     uploadStatus.style.color = '#ef4444';
     return;
  }

  if (uploadedVideoInfo && uploadedVideoInfo.url && uploadedVideoInfo.url.startsWith('blob:')) {
    URL.revokeObjectURL(uploadedVideoInfo.url);
  }
  const objectURL = URL.createObjectURL(file);
  uploadedVideoInfo = { name: file.name, url: objectURL, file };
  
  addDebugLog(`已選擇檔案: ${file.name}`, 'info');
  
  if (currentMode === 'uploaded') {
    player.src = uploadedVideoInfo.url;
    player.load();
    meta.textContent = `預覽檔案：${uploadedVideoInfo.name}`;
    updateProgress();
  }
  
  uploadStatus.textContent = `已選擇檔案：${file.name}，點擊「上傳並分析」開始。`;
  uploadStatus.style.color = '#eaeaea'; 
  resetKbertPanel();
  updateAnalysisStatusUI('initial');
  stopPolling();
  currentAnalysisReport = null; 
  resetAiReport();
}

videoUploader.addEventListener('change', () => {
  const file = videoUploader.files[0];
  handleFileSelect(file);
  videoUploader.value = ''; 
});

multiUploadZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
  multiUploadZone.style.borderColor = '#4a9eff'; 
  multiUploadZone.style.backgroundColor = '#1a1e24';
});

multiUploadZone.addEventListener('dragleave', (e) => {
  e.preventDefault();
  e.stopPropagation();
  multiUploadZone.style.borderColor = '#333946';
  multiUploadZone.style.backgroundColor = 'transparent';
});

multiUploadZone.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();
  multiUploadZone.style.borderColor = '#333946';
  multiUploadZone.style.backgroundColor = 'transparent';
  
  addDebugLog('偵測到檔案拖放', 'info');
  const files = e.dataTransfer.files;
  
  if (files && files.length > 0) {
    if (files.length > 1) {
      addDebugLog(`你拖放了 ${files.length} 個檔案，目前只會處理第一個。`, 'warning');
    }
    const file = files[0]; 
    handleFileSelect(file);
  } else {
    addDebugLog('拖放事件未包含檔案', 'warning');
  }
});

uploadButton.onclick = async () => {
  if (!uploadedVideoInfo || !uploadedVideoInfo.file) {
    uploadStatus.textContent = '錯誤：請先選擇一個影片檔案！';
    addDebugLog('上傳按鈕點擊，但未選擇檔案', 'warning');
    currentAnalysisReport = null; 
    return;
  }
  const file = uploadedVideoInfo.file;
  const fileName = uploadedVideoInfo.name;

  addDebugLog(`準備上傳檔案: ${fileName}`, 'info');
  stopPolling();
  resetKbertPanel();
  updateAnalysisStatusUI('uploading');
  uploadStatus.textContent = `[1/4] 上傳中 (${fileName})，請稍候...`;
  uploadButton.disabled = true;
  document.getElementById('testAI').disabled = true;

  const formData = new FormData();
  formData.append('video', file, fileName);

  try {
    addDebugLog('呼叫 /api/upload...', 'info');
    const res = await fetch('/api/upload', { method: 'POST', body: formData });
    const result = await res.json();
    if (res.ok) {
      addDebugLog(`/api/upload 成功: ${JSON.stringify(result)}`, 'success');
      uploadStatus.textContent = `[2/4] 上傳成功！開始等待分析結果 (${fileName})...`;
      updateAnalysisStatusUI('pending');
      if (currentMode !== 'uploaded') {
        document.querySelector('input[name="sceneMode"][value="uploaded"]').checked = true;
        switchMode('uploaded');
      } else {
        player.src = uploadedVideoInfo.url;
        player.load();
        meta.textContent = `預覽檔案：${fileName}`;
      }
      startPollingForResult(fileName);
    } else {
      const errorMsg = result?.error || `HTTP ${res.status} ${res.statusText}`;
      addDebugLog(`/api/upload 失敗: ${errorMsg}`, 'error');
      throw new Error(errorMsg);
    }
  } catch (e) {
    const errorMsg = e.message || '未知的上傳錯誤';
    uploadStatus.textContent = `上傳失敗：${errorMsg}`;
    updateAnalysisStatusUI('error', `上傳失敗: ${errorMsg}`);
    addDebugLog(`上傳或處理 /api/upload 回應時發生錯誤: ${errorMsg}`, 'error');
  } finally {
    uploadButton.disabled = false;
    document.getElementById('testAI').disabled = false;
  }
};

// --- 初始化 ---
addDebugLog('頁面載入，TV Subtitle Debug 系統啟動', 'success');
document.addEventListener('DOMContentLoaded', async () => {
  addDebugLog('DOM Ready, 開始初始化...', 'info');
  toggleControlsForMode(currentMode);
  resetKbertPanel();
  updateAnalysisStatusUI('initial');
  await loadManifest();
});
</script>
</body>
</html>
